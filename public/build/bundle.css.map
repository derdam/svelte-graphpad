{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../Graph.svelte",
    "../../Tool.svelte",
    "../../AudioPlayer.svelte"
  ],
  "sourcesContent": [
    "<script>\n  //\timport AudioPlayer, { stopAll } from './AudioPlayer.svelte';\n\t import * as vis from 'vis-network'\n   import { onMount } from 'svelte';\n   import { nodes, edges, addNode, updateNode, addEdge, removeNode, removeEdge, updateEdge } from './GraphStore.js';\n   import { buildNodeView } from './NodeView.js';\n   import { buildEdgeView } from './EdgeView.js';\n   import NodeEditor from './NodeEditor.svelte';\n   import EdgeEditor from './EdgeEditor.svelte';\n   import NodeEditorDocument from './NodeEditorDocument.svelte';\n   import NodeEditorValidator from './NodeEditorValidator.svelte';\n   import NodeEditorValidatorRejected from './NodeEditorValidatorRejected.svelte';\n   import NodeEditorValidatorAccepted from './NodeEditorValidatorAccepted.svelte';\n   import NodeEditorAudio from './NodeEditorAudio.svelte';\n   import NodeEditorAddress from './NodeEditorAddress.svelte';\n   import NodeEditorYoutube from './NodeEditorYoutube.svelte'\n   import GraphData, { restore } from './GraphData.svelte';\n   import Tool from './Tool.svelte';\n\n\n  let container = { \n     EdgeEditor: EdgeEditor,\n     NodeEditor: NodeEditor,\n     NodeEditorDocument: NodeEditorDocument,\n     NodeEditorValidator: NodeEditorValidator,\n     NodeEditorValidatorAccepted,NodeEditorValidatorAccepted,\n     NodeEditorValidatorRejected: NodeEditorValidatorRejected,\n     NodeEditorAudio:NodeEditorAudio,\n     NodeEditorAddress:NodeEditorAddress,\n     NodeEditorYoutube:NodeEditorYoutube\n   }\n\n   let selection = {nodes: [], edges: []};\n\n\n   let nodeEditors = [NodeEditor];\n      let edgeEditors = [EdgeEditor];\n\n   $: nodesSelected = selection.nodes.length;\n   $: node1 = nodes.get(selection.nodes.slice(0,1));\n   $: node2 = nodes.get(selection.nodes.slice(1,2));\n   $: edge1 = edges.get(selection.edges.slice(0,1));\n\n   $: canAddEdge = selection.nodes.length === 2;\n   $: canDeleteEdge = selection.nodes.length === 0 && selection.edges.length === 1;\n   $: canDeleteNodes = selection.nodes.length > 0;\n   $: canAddNode = selection.nodes.length <= 1;\n   $: canEditNode = selection.nodes.length === 1;\n   $: canEditEdge = selection.edges.length === 1 && !canEditNode;\n\n   let nodeChangeSignal = 0;\n\n    $: {\n    if (canEditNode) {\n    \n        let editor = null;\n        let editors = [];\n\n        // capture nodeChangeSignal property changes\n        let trigger = nodeChangeSignal;\n\n        //console.log(\"signal: \", trigger)\n        //console.log(\"nodeEditor2 evaluated. nodeClass=\" + node1[0].nodeClass);\n\n        if (node1[0].nodeClass)\n        {\n          editor = container[\"NodeEditor\"+node1[0].nodeClass]\n          \n          let tokens = node1[0].nodeClass.split(\" \");\n          console.log(tokens);\n\n          tokens.forEach(t=> {\n            let e = container[\"NodeEditor\"+t];\n            if (t!==\"\") {\n              editors.push(e);\n            }\n\n          })\n          \n         \n        } \n        \n        nodeEditors = [...editors];\n    }\n  }\n\nlet edgeChangeSignal = 0;\n\n   $: {\n    if (canEditEdge) {\n    \n        let editor = null;\n        let editors = [];\n\n        // capture nodeChangeSignal property changes\n        let trigger = edgeChangeSignal;\n\n        //console.log(\"signal: \", trigger)\n        //console.log(\"nodeEditor2 evaluated. nodeClass=\" + node1[0].nodeClass);\n\n        if (edge1[0].nodeClass)\n        {\n          editor = container[\"EdgeEditor\"+edge1[0].edgeClass]\n          \n          let tokens = edge1[0].edgeClass.split(\" \");\n          console.log(tokens);\n\n          tokens.forEach(t=> {\n            let e = container[\"EdgeEditor\"+t];\n            if (t!==\"\") {\n              editors.push(e);\n            }\n\n          })\n          \n         \n        } \n        \n        edgeEditors = [...editors];\n    }\n  }\n\n  let inh;\n  let inw;\n\n\n\n  var data = {\n    nodes: nodes,\n    edges: edges\n  };\n\n  let options = {\n    physics:{\n    enabled: true,\n    barnesHut: {\n      gravitationalConstant: -2000,\n      centralGravity: 0.3,\n      springLength: 95,\n      springConstant: 0.04,\n      damping: 0.09,\n      avoidOverlap: 0.0\n    }},\n   autoResize: true,\n            height: '100%',\n            width: '100%',\n    interaction: { multiselect: true },\n    nodes:{\n      font: {color: '#ffffff'},\n      shapeProperties: {\n              useBorderWithImage:false,\n              interpolation:true\n      },\n      color:'#0077C8' \n    }, edges: {\n      smooth: { enabled: false}\n    }\n  };\n\n\n\n\n  let network;\n\n  onMount(async () => {\n    // create a network\n    var container = document.getElementById('mynet');\n    network = new vis.Network(container, data, options);    \n    network.on(\"select\", function (params) {\n      // nodeSelection.selectNode(params.nodes[0]);\n        selection = params;\n    });\n\n\n    let nodeUpdating = false;\n    nodes.on('update', function (event, properties, senderId) { \n     if (!nodeUpdating) {\n       //  console.log(\"node.on update: \"+JSON.stringify(properties));\n        nodeUpdating = true;\n         let view = buildNodeView(properties.data[0]);\n     \n        let node = {...properties.data[0], ...view};\n       \n       updateNode(node);\n\n       nodeChangeSignal++;\n       // alert(JSON.stringify(node));\n     \n       nodeUpdating = false;\n     }\n    });\n\n   \n let edgeUpdating = false;\n    edges.on('update', function (event, properties, senderId) { \n     if (!edgeUpdating) {\n       //  console.log(\"node.on update: \"+JSON.stringify(properties));\n        edgeUpdating = true;\n         let view = buildEdgeView(properties.data[0]);\n     \n        let edge = {...properties.data[0], ...view};\n       \n       updateEdge(edge);\n\n       edgeChangeSignal++;\n       // alert(JSON.stringify(node));\n     \n       edgeUpdating = false;\n     }\n    });\n\n    setTimeout(() => {\n          network.fit();\n        }, 1000);\n  \n  });\n  \n\n   function addNewEdge() {\n    if (nodesSelected === 2) {\n        addEdge({from: node1[0].id, to: node2[0].id, label: ''});\n    }\n   }\n\n   function deleteEdge() {\n       // alert(JSON.stringify(edge1));\n        removeEdge(edge1[0]);\n        selection.edges = []\n   }\n\n   function deleteNodes() {\n     removeEdge(selection.edges);\n     removeNode(selection.nodes);\n   }\n\n   function addNewNode(attr, edgeattr) {\n     if (nodesSelected <= 1) {\n      var newNode = addNode({label: 'New\\nNode', ...attr});\n      if (nodesSelected===1) {\n        //alert(\"foo. \"+JSON.stringify(node1.id);\n        var newEdge = addEdge({from: node1[0].id, to: newNode[0], label: '', ...edgeattr});\n         selection.edges = []; \n      }\n        selection.nodes = newNode;\n        network.selectNodes(newNode);\n     }\n    };\n\n    function sampleDocumentNode() {\n     // return {shape: 'image', size:45, image: './Austrian_ID_card.jpg'}\n     return {nodeClass:'Document'}\n    \n    }\n\n\n      function sampleIdDocumentNode() {\n    return {shape: 'image', size:45, image: './Austrian_ID_card.jpg'}\n    \n    \n    }\n\n\n     function sampleLegalDocumentNode() {\n      return {shape: 'image',   size:45, image: './contract-signing.png'}\n    }\n\n    function addNewDocumentNode() {\n      addNewNode({...sampleDocumentNode(), nodeClass:\"Document\"},\n      {});\n    }\n\n\n    function addNewSingleAccount() {\n      nodes.clear();\n      edges.clear();\n    //  let x = `${someone} was looking for ${something} in the general vicinity of ${somewhere}`;\n      addNode([\n        {id: \"sa_mandate\", label: \"Single\\nAccount\"},\n        {id: \"sa_ah1\", label: \"Account\\nHolder\"},\n        {id: \"sa_bo1\", label: \"Beneficial\\nOwner\"},\n        {id: \"sa_np1\", label: \"Natural\\nPerson\"},\n        {id: \"sa_np1_id\", label: \"ID Card\", nodeClass:\"Document\", ...sampleIdDocumentNode()},\n        {id: \"sa_ah1_doc0\", label: \"Form 0\", nodeClass:\"Document\", ...sampleLegalDocumentNode()},\n        {id: \"sa_bo1_doc4\", label: \"Form 4\",nodeClass:\"Document\", ...sampleLegalDocumentNode()},\n       \n        \n      ]);\n      addEdge([\n        {from: \"sa_mandate\", to:\"sa_ah1\"},\n        {from: \"sa_mandate\", to:\"sa_bo1\"},\n        {from: \"sa_ah1\", to:\"sa_np1\"},\n        {from: \"sa_bo1\", to:\"sa_np1\"},\n        {from: \"sa_np1\", to:\"sa_np1_id\"},\n        {from: \"sa_ah1\", to:\"sa_ah1_doc0\"},\n        {from: \"sa_bo1\", to:\"sa_bo1_doc4\"},\n      ]);\n\n    }\n\n    // Event handlers \n    function fit() {\n      network.fit();\n    }\n\n</script>\n\n<style>\n  .editZone {\n      position:absolute;\n      left:82%;\n      width:18%;\n     \n      z-index:99; \n      opacity:0.8; \n    }\n\n    .graph {\n      position: absolute;\n      top: -2px;\n      left:-2px;\n      width: 101%;\n      height:400px;\n    }\n</style>\n\n\n<svelte:window bind:innerHeight={inh} innerWidth={inw}/>\n\n<div class=\"l0 editZone\">\n\n<Tool title=\"View\">\n  <button on:click={fit}>Center</button>\n</Tool>\n\n\n\n<!-- <GraphData></GraphData> -->\n{#if canAddNode && !canEditEdge}\n  <Tool title=\"Graph\">\n   <button on:click={addNewNode}>New node</button>\n  {#if canDeleteNodes}\n    <button on:click={deleteNodes}>Delete node{ nodesSelected > 1 ? '(s)':''}</button>\n  {/if}\n\n  \n  </Tool>\n {/if}\n\n{#if canAddEdge | canEditEdge | canDeleteEdge}\n <Tool title=\"Graph\">\n {#if canAddEdge}\n    <button on:click={addNewEdge}>Add Edge</button>\n  {/if}\n\n  {#if canDeleteEdge}\n    <button on:click={deleteEdge}>Delete Edge</button>\n  {/if}\n\n\n  {#if canEditEdge}\n    <Tool title = \"Edge\">\n      <EdgeEditor edge={edge1[0]}></EdgeEditor>\n      {#each edgeEditors as editor}\n         <svelte:component this={editor} edge={edge1[0]} ></svelte:component>\n   \n      {/each}\n    </Tool>\n  {/if}\n  </Tool>\n{/if}\n  {#if canEditNode}\n    <Tool title = \"Node\">\n      <!-- <NodeEditor node={node1[0]} on:message={nodeUpdated}></NodeEditor> -->\n      <NodeEditor node={node1[0]} >\n      <!-- {#if nodeEditor2 !==null}\n      <svelte:component this={nodeEditor2} node={node1[0]} ></svelte:component>\n      {/if}\n      -->\n      {#each nodeEditors as editor}\n         <svelte:component this={editor} node={node1[0]} ></svelte:component>\n   \n      {/each}\n      </NodeEditor>\n    </Tool>\n  {/if}\n\n  \n\n  {#if !canEditNode && !canEditEdge} \n    <Tool title=\"Data\">\n      <GraphData></GraphData>\n    </Tool>\n    <button on:click={addNewDocumentNode}>New document</button>\n    <button on:click={addNewSingleAccount}>New Single Account</button> \n  {/if}\n\n</div>\n<div id =\"mynet\" class=\"graph\" style=\"height:{inh+2}px\">\n</div>\t\n",
    "<script>\n    export let title = \"Tool\";\n</script>\n\n<style>\n    .tool {\n        background-color:#212121;\n        border-top: 1px;\n        border-left: 0px;\n        border-right: 0px;\n        border-bottom:  0px;\n        border-style: solid;\n        border-color: #444444;\n       \n    }\n\n    .title {\n        background-color: #2c2c2c;\n     \n    }\n\n</style>\n\n<div class=\"tool\">\n    <div class=\"title\">{title}</div>\n    <slot></slot>\n</div>",
    "<script context=\"module\">\n\tconst elements = new Set();\n\n\texport function stopAll() {\n\t\telements.forEach(element => {\n\t\t\telement.pause();\n\t\t});\n\t}\n</script>\n\n<script>\n\timport { onMount } from 'svelte';\n\n\texport let src;\n\texport let title;\n\texport let composer;\n\texport let performer;\n\n\tlet audio;\n\tlet paused = true;\n\n\tonMount(() => {\n        elements.add(audio);      \n  \t\treturn () => elements.delete(audio);\n\t});\n\n\tfunction stopOthers() {\n\t\telements.forEach(element => {\n\t\t\tif (element !== audio) element.pause();\n\t\t});\n    }\n    \n        function next() {\n           // alert(\"next\");\n        }\n\n\n        \n</script>\n\n<style>\n\tarticle { margin: 0 0 1em 0; max-width: 800px }\n\th2, p { margin: 0 0 0.3em 0; }\n\taudio { width: 100%; margin: 0.5em 0 1em 0; }\n\t.playing { color: #ff3e00; }\n</style>\n\n<article class:playing={!paused}>\n\t<h2>{title}</h2>\n\t<p><strong>{composer}</strong> / performed by {performer}</p>\n\n\t<audio\n\t\tbind:this={audio}\n\t\tbind:paused\n\t\ton:play={stopOthers}\n        on:ended={next}\n\t\tcontrols\n\t\t{src}\n\t></audio>\n</article>"
  ],
  "names": [],
  "mappings": "AAmTE,SAAS,eAAC,CAAC,AACP,SAAS,QAAQ,CACjB,KAAK,GAAG,CACR,MAAM,GAAG,CAET,QAAQ,EAAE,CACV,QAAQ,GAAG,AACb,CAAC,AAED,MAAM,eAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,KAAK,IAAI,CACT,KAAK,CAAE,IAAI,CACX,OAAO,KAAK,AACd,CAAC;AC7TD,KAAK,eAAC,CAAC,AACH,iBAAiB,OAAO,CACxB,UAAU,CAAE,GAAG,CACf,WAAW,CAAE,GAAG,CAChB,YAAY,CAAE,GAAG,CACjB,aAAa,CAAG,GAAG,CACnB,YAAY,CAAE,KAAK,CACnB,YAAY,CAAE,OAAO,AAEzB,CAAC,AAED,MAAM,eAAC,CAAC,AACJ,gBAAgB,CAAE,OAAO,AAE7B,CAAC;ACsBJ,OAAO,cAAC,CAAC,AAAC,MAAM,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAE,SAAS,CAAE,KAAK,CAAC,CAAC,AAC/C,gBAAE,CAAE,CAAC,cAAC,CAAC,AAAC,MAAM,CAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,AAAE,CAAC,AAC9B,KAAK,cAAC,CAAC,AAAC,KAAK,CAAE,IAAI,CAAE,MAAM,CAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,AAAE,CAAC,AAC7C,QAAQ,cAAC,CAAC,AAAC,KAAK,CAAE,OAAO,AAAE,CAAC"
}